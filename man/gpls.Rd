% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gpls.R
\name{gpls}
\alias{gpls}
\title{Iterative estimation of penalised generalised least squares}
\usage{
gpls(
  data,
  glsSt,
  xNames,
  outVar,
  coords = c("x", "y"),
  corMat,
  lambda,
  maxIter = 30,
  tol = 0.05,
  verbose = FALSE,
  optControl = lmeControl(opt = "optim", maxIter = 500, msVerbose = verbose, msMaxIter
    = 500, niterEM = 1000, msMaxEval = 1000),
  nfolds = 10,
  ...
)
}
\arguments{
\item{data}{A data matrix or data frame}

\item{glsSt}{a covariance structure, as supplied to nlme::gls as "correlation"}

\item{xNames}{names of the regressors in data}

\item{outVar}{name of the outcome variable in data}

\item{coords}{Names of the spatial covariates, used by glsSt}

\item{corMat}{a starting value for th correlation matrix. Taken to be a diagonal matrix if missing}

\item{lambda}{The penalty value for glmnet. If missing, the optimal value of vanilla glmnet without autocorrelation component is used}

\item{maxIter}{maximum number of iterations between glmnet and gls}

\item{tol}{A convergence tolerance}

\item{verbose}{a boolean, should output be printed?}

\item{optControl}{control arguments, passed onto nlme::gls' control argument}

\item{nfolds}{an integer, the number of folds used in cv.glmnet to find lambda}

\item{...}{passed onto glmnet::glmnet}

\item{Coef}{a starting value for coefficients}
}
\value{

}
\description{
Iterative estimation of penalised generalised least squares
}
\details{
This function does not provide cross-validation, but rather fits the model
for the lambda penalty value provided, or else the optimal lambda value of the vanilla glmnet.
Cross-validation needs to be implemented by the user; since the data exhibits autocorrelation
this may need to be blocked cross-validation or some other dedicated method.
}
\examples{
# Define the dimensions of the data
n = 50 #Sample size
p = 100 #Number of features
g = 10 #Size of the grid
#Generate grid
Grid = expand.grid("x" = seq_len(g), "y" = seq_len(g))
# Sample points from grid without replacement
GridSample = Grid[sample(nrow(Grid), n, replace = FALSE),]
#Generate outcome and regressors
a = rnorm(n)
b = matrix(rnorm(p*n), n , p)
#Compile to a matrix
df = data.frame("a" = a, "b" = b, GridSample)
# Define the correlation structure (see ?nlme::gls), with initial nugget 0.5 ang range 5
corStruct = corGaus(form = ~ x + y, nugget = TRUE, value = c("range" = 5, "nugget" = 0.5))
#Fit the gpls model, for simplicity for a simple lambda
gplsFit = gpls(data = df, outVar = "a", xNames = grep(names(df), pattern = "b", value =TRUE), glsSt = corStruct, nfolds = 5)
}
