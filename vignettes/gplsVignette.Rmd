---
output: 
  rmarkdown::html_vignette:
    toc: true
    keep_md: true
vignette: >
  %\VignetteIndexEntry{Manual for the RCM pacakage}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# gpls package: vignette

\setcounter{tocdepth}{5}
\tableofcontents

# Introduction

This vignette demonstrates the use of the _gpls_ package for high-dimensional data with spatial or temporal autocorrelation. It consists of an iterative loop around the _nlme_ and _glmnet_ packages.

# Installation instuction

The _gpls_ package is available from BioConductor, and can be installed as follows:

```{r install, eval = FALSE}
library(BiocManager)
install("gpls", update = FALSE)
```

Once installed, it can be loaded and version info printed.

```{r loadRCMpackage}
suppressPackageStartupMessages(library(gpls))
cat("gpls package version", as.character(packageVersion("gpls")), "\n")
```

# Illustration

## Spatial autocorrelation

We first create a toy dataset with spatial coordinates.

```{r spatialToy}
library(nlme)
n = 50 #Sample size
p = 100 #Number of features
g = 10 #Size of the grid
#Generate grid
Grid = expand.grid("x" = seq_len(g), "y" = seq_len(g))
# Sample points from grid without replacement
GridSample = Grid[sample(nrow(Grid), n, replace = FALSE),]
#Generate outcome and regressors
a = rnorm(n)
b = matrix(rnorm(p*n), n , p)
#Compile to a matrix
df = data.frame("a" = a, "b" = b, GridSample)
```

The _gpls_ method requires prespecification of a functional form for the autocorrelation. This is done through the _corStruct_ objects defined by the _nlme_ package. We specify a correlation decaying as a Gaussian curve with distance, and with a nugget parameter. The nugget parameter is a proportion that indicates how much of the correlation structure explained by independent errors; the rest is attributed to spatial autocorrelation. The starting values are chosen as reasonable guesses; they will be overwritten in the fitting process.

```{r spatialCorrelation}
# Define the correlation structure (see ?nlme::gls), with initial nugget 0.5 and range 5
corStruct = corGaus(form = ~ x + y, nugget = TRUE, value = c("range" = 5, "nugget" = 0.5))
```

Finally the model is fitted with a single outcome variable and large number of regressors, with the chosen covariance structure and for a prespecified penalty parameter $\lambda=0.2$.

```{r spatialFit}
#Fit the gpls model, for simplicity for a simple lambda
gplsFit = gpls(data = df, outVar = "a", xNames = grep(names(df), pattern = "b", value =TRUE),
glsSt = corStruct, lambda = 0.2)
```

Standard extraction functions like print(), coef() and predict() are defined for the new "gpls" object.

```{r standardExtract}
gplsFit
gplsCoef = coef(gplsFit)
gplsPred = predict(gplsFit)
```

## Temporal autocorrelation

The method can also account for temporal autocorrelation by defining another correlation structure from the _nlme_ package, 

```{r timeSetup}
### Example 2: timecourse data
dfTime = data.frame("a" = a, "b" = b, "t" = seq_len(50))
corStructTime = corAR1(form = ~ t, value = 0.5)
gplsFit = gpls(data = dfTime, outVar = "a",
xNames = grep(names(dfTime), pattern = "b", value =TRUE),
glsSt = corStructTime, nfolds = 5)
```

